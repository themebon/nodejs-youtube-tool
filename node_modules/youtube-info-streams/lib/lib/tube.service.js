"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.YTubeService = void 0;
/*
 * String#indexOf() that supports regex too.
 */
var indexOf = function (haystack, needle) {
    return needle instanceof RegExp ?
        haystack.search(needle) : haystack.indexOf(needle);
};
var jsonClosingChars = /^[)\]}'\s]+/;
var YTubeService = /** @class */ (function () {
    function YTubeService() {
        this.VIDEO_URL = 'https://www.youtube.com/watch?v=';
        this.EMBED_URL = 'https://www.youtube.com/embed/';
        this.VIDEO_EURL = 'https://youtube.googleapis.com/v/';
        this.INFO_HOST = 'www.youtube.com';
        this.INFO_PATH = '/get_video_info';
    }
    YTubeService.prototype.gotConfig = function (id, additional, info, cver) {
        return __awaiter(this, void 0, void 0, function () {
            var player_response;
            return __generator(this, function (_a) {
                player_response = info && ((info.args && info.args.player_response) ||
                    info.player_response || info.playerResponse || info.embedded_player_response);
                /*  if (!player_response) {
                    const url = urllib.format({
                      protocol: 'https',
                      host: this.INFO_HOST,
                      pathname: this.INFO_PATH,
                      query: {
                        video_id: id,
                        eurl: this.VIDEO_EURL + id,
                        ps: 'default',
                        c: 'TVHTML5',
                        cver: `7${cver.substr(1)}`,
                        gl: 'US',
                        hl: 'en',
                        html5: 1,
                      },
                    });
              
                    const respo = await got.get(url, {headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.101 Safari/537.36'
                      }});
              
                    const moreinfo: any = querystring.parse(respo.body);
                    player_response = moreinfo.player_response || info.playerResponse || info.embedded_player_response;
                  }*/
                if (!player_response || typeof player_response === 'object') {
                    info.player_response = player_response;
                }
                else {
                    try {
                        player_response = player_response.replace(jsonClosingChars, '');
                        info.player_response = JSON.parse(player_response);
                    }
                    catch (err) {
                        throw Error("Error parsing `player_response`: " + err.message);
                    }
                }
                info.formats = this.parseFormats(info);
                info.videoDetails = Object.assign({}, info.player_response.microformat.playerMicroformatRenderer, info.player_response.videoDetails, additional);
                info.html5player = info.player && info.player.assets && info.player.assets.js;
                // Add additional properties to info.
                Object.assign(info, additional, {
                    video_id: id,
                    // Give the standard link to the video.
                    video_url: this.VIDEO_URL + id,
                    // Copy over a few props from `player_response.videoDetails`
                    // for backwards compatibility.
                    title: info.player_response.videoDetails && info.player_response.videoDetails.title,
                    length_seconds: info.player_response.videoDetails && info.player_response.videoDetails.lengthSeconds,
                });
                return [2 /*return*/, info];
            });
        });
    };
    YTubeService.prototype.stripHTML = function (html) {
        return html
            .replace(/[\n\r]/g, ' ')
            .replace(/\s*<\s*br\s*\/?\s*>\s*/gi, '\n')
            .replace(/<\s*\/\s*p\s*>\s*<\s*p[^>]*>/gi, '\n')
            .replace(/<a\s+(?:[^>]*?\s+)?href=(?:["'])\/redirect.*?q=(.*?)(?:[&'"]).*?<\/a>/gi, function (_, p1) { return decodeURIComponent(p1); })
            .replace(/<.*?>/gi, '')
            .trim();
    };
    YTubeService.prototype.parseFormats = function (info) {
        var formats = [];
        if (info.player_response.streamingData) {
            if (info.player_response.streamingData.formats) {
                formats = formats.concat(info.player_response.streamingData.formats);
            }
            if (info.player_response.streamingData.adaptiveFormats) {
                formats = formats.concat(info.player_response.streamingData.adaptiveFormats);
            }
        }
        return formats;
    };
    /*
  * Extract string inbetween another.
  */
    YTubeService.prototype.between = function (haystack, left, right) {
        var pos;
        if (left instanceof RegExp) {
            var match = haystack.match(left);
            if (!match) {
                return '';
            }
            pos = match.index + match[0].length;
        }
        else {
            pos = haystack.indexOf(left);
            if (pos === -1) {
                return '';
            }
            pos += left.length;
        }
        haystack = haystack.slice(pos);
        pos = haystack.indexOf(right);
        if (pos === -1) {
            return '';
        }
        haystack = haystack.slice(0, pos);
        return haystack;
    };
    YTubeService.prototype.parallel = function (funcs, callback) {
        var funcsDone = 0;
        var errGiven = false;
        var results = [];
        var len = funcs.length;
        var checkDone = function (index, err, result) {
            if (errGiven) {
                return;
            }
            if (err) {
                errGiven = true;
                callback(err);
                return;
            }
            results[index] = result;
            if (++funcsDone === len) {
                callback(null, results);
            }
        };
        if (len > 0) {
            funcs.forEach(function (f, i) { f(checkDone.bind(null, i)); });
        }
        else {
            callback(null, results);
        }
    };
    YTubeService.prototype.cutAfterJSON = function (mixedJson) {
        var open;
        var close;
        if (mixedJson[0] === '[') {
            open = '[';
            close = ']';
        }
        else if (mixedJson[0] === '{') {
            open = '{';
            close = '}';
        }
        if (!open) {
            throw new Error("Can't cut unsupported JSON (need to begin with [ or { ) but got: " + mixedJson[0]);
        }
        // States if the loop is currently in a string
        var isString = false;
        // Current open brackets to be closed
        var counter = 0;
        var i;
        for (i = 0; i < mixedJson.length; i++) {
            // Toggle the isString boolean when leaving/entering string
            if (mixedJson[i] === '"' && mixedJson[i - 1] !== '\\') {
                isString = !isString;
                continue;
            }
            if (isString)
                continue;
            if (mixedJson[i] === open) {
                counter++;
            }
            else if (mixedJson[i] === close) {
                counter--;
            }
            // All brackets have been closed, thus end of JSON is reached
            if (counter === 0) {
                // Return the cut JSON
                return mixedJson.substr(0, i + 1);
            }
        }
        // We ran through the whole string and ended up with an unclosed bracket
        throw Error("Can't cut unsupported JSON (no matching closing bracket found)");
    };
    ;
    YTubeService.prototype.playError = function (info, status) {
        var playability = info.playerResponse.playabilityStatus;
        if (playability && playability.status === status) {
            return Error(playability.reason || (playability.messages && playability.messages[0]));
        }
        return null;
    };
    ;
    return YTubeService;
}());
exports.YTubeService = YTubeService;
